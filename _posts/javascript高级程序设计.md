---
title: javascript高级程序设计
date: 2018-01-30 17:31:19
tags:
---
- [1. JavaScript简介](#1-javascript%E7%AE%80%E4%BB%8B)
    - [1.1. JavaScript简史](#11-javascript%E7%AE%80%E5%8F%B2)
    - [1.2. JavaScript实现](#12-javascript%E5%AE%9E%E7%8E%B0)
- [2. 在HTML中使用JavaScript](#2-%E5%9C%A8html%E4%B8%AD%E4%BD%BF%E7%94%A8javascript)
    - [2.1. &lt;script&gt;元素](#21-ltscriptgt%E5%85%83%E7%B4%A0)
        - [2.1.1. 延迟脚本](#211-%E5%BB%B6%E8%BF%9F%E8%84%9A%E6%9C%AC)
        - [2.1.2. 异步脚本](#212-%E5%BC%82%E6%AD%A5%E8%84%9A%E6%9C%AC)
        - [2.1.3. 在XHTML中的用法](#213-%E5%9C%A8xhtml%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95)
    - [2.2. 嵌入代码与外部文件](#22-%E5%B5%8C%E5%85%A5%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6)
- [3. 基本概念](#3-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5)
    - [3.1. 语法](#31-%E8%AF%AD%E6%B3%95)
        - [3.1.1. 区分大小写](#311-%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99)
        - [3.1.2. 严格模式](#312-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F)
    - [3.2. 变量](#32-%E5%8F%98%E9%87%8F)
    - [3.3. 数据类型](#33-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
        - [3.3.1. typeof操作符](#331-typeof%E6%93%8D%E4%BD%9C%E7%AC%A6)
        - [3.3.2. Undefined类型](#332-undefined%E7%B1%BB%E5%9E%8B)
        - [3.3.3. Null类型](#333-null%E7%B1%BB%E5%9E%8B)
        - [3.3.4. Boolean类型](#334-boolean%E7%B1%BB%E5%9E%8B)
        - [3.3.5. Number类型](#335-number%E7%B1%BB%E5%9E%8B)
        - [3.3.6. String类型](#336-string%E7%B1%BB%E5%9E%8B)
        - [3.3.7. Object类型](#337-object%E7%B1%BB%E5%9E%8B)
    - [3.4. 操作符](#34-%E6%93%8D%E4%BD%9C%E7%AC%A6)
        - [3.4.1. 位操作符](#341-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6)
        - [3.4.2. 布尔操作符](#342-%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6)
        - [3.4.3. 乘性操作符](#343-%E4%B9%98%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6)
        - [3.4.4. 相等操作符](#344-%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6)
    - [3.5. 语句](#35-%E8%AF%AD%E5%8F%A5)
        - [3.5.1. label语句](#351-label%E8%AF%AD%E5%8F%A5)
        - [3.5.2. with语句](#352-with%E8%AF%AD%E5%8F%A5)
    - [3.6. 函数](#36-%E5%87%BD%E6%95%B0)
        - [3.6.1. 理解参数](#361-%E7%90%86%E8%A7%A3%E5%8F%82%E6%95%B0)
- [4. 变量、作用域和内存问题](#4-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98)
    - [4.1. 基本类型和引用类型的值](#41-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC)
        - [4.1.1. 传递参数](#411-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0)
        - [4.1.2. 检测类型](#412-%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B)
    - [4.2. 执行环境及作用域](#42-%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F)
        - [4.2.1. 没有块级作用域](#421-%E6%B2%A1%E6%9C%89%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F)
    - [4.3. 垃圾收集](#43-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86)
        - [4.3.1. 标记清除](#431-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4)
        - [4.3.2. 引用计数](#432-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0)
        - [4.3.3. 管理内存](#433-%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98)
- [5. 引用类型](#5-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B)
    - [5.1. Object类型](#51-object%E7%B1%BB%E5%9E%8B)
    - [5.2. Array类型](#52-array%E7%B1%BB%E5%9E%8B)
        - [5.2.1. 检测数组](#521-%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84)
        - [5.2.2. 栈方法](#522-%E6%A0%88%E6%96%B9%E6%B3%95)
        - [5.2.3. 队列方法](#523-%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95)
        - [5.2.4. 重排序方法](#524-%E9%87%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95)
        - [5.2.5. 操作方法](#525-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95)
            - [5.2.5.1. concat()方法](#5251-concat%E6%96%B9%E6%B3%95)
            - [5.2.5.2. slice()方法](#5252-slice%E6%96%B9%E6%B3%95)
            - [5.2.5.3. splice()方法（最强大的数组方法）](#5253-splice%E6%96%B9%E6%B3%95%EF%BC%88%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%EF%BC%89)
        - [5.2.6. 位置方法](#526-%E4%BD%8D%E7%BD%AE%E6%96%B9%E6%B3%95)
        - [5.2.7. 迭代方法](#527-%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95)
        - [5.2.8. 缩小方法](#528-%E7%BC%A9%E5%B0%8F%E6%96%B9%E6%B3%95)
    - [5.3. Date 类型](#53-date-%E7%B1%BB%E5%9E%8B)
        - [5.3.1. Date.parse()](#531-dateparse)
        - [5.3.2. Date.UTC()](#532-dateutc)
    - [5.4. RegExp类型](#54-regexp%E7%B1%BB%E5%9E%8B)
        - [5.4.1. RegExp 实例属性](#541-regexp-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7)
        - [5.4.2. RegExp 实例方法](#542-regexp-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95)
        - [5.4.3. RegExp 构造函数属性](#543-regexp-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7)
    - [5.5. Function类型](#55-function%E7%B1%BB%E5%9E%8B)
        - [5.5.1. 函数声明与函数表达式](#551-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F)
        - [5.5.2. 作为值的函数](#552-%E4%BD%9C%E4%B8%BA%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0)
        - [5.5.3. 函数内部属性](#553-%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7)
        - [5.5.4. 函数的属性和方法](#554-%E5%87%BD%E6%95%B0%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95)
    - [5.6. 基本包装类型](#56-%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B)
        - [5.6.1. Boolean 类型](#561-boolean-%E7%B1%BB%E5%9E%8B)
        - [5.6.2. Number 类型](#562-number-%E7%B1%BB%E5%9E%8B)
        - [5.6.3. String 类型](#563-string-%E7%B1%BB%E5%9E%8B)
    - [单体内置对象](#%E5%8D%95%E4%BD%93%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1)
- [6. 面向对象的程序设计](#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)
- [7. 函数表达式](#7-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F)
- [8. BOM](#8-bom)
- [9. 客户端检测](#9-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A3%80%E6%B5%8B)
- [10. DOM](#10-dom)
- [11. DOM扩展](#11-dom%E6%89%A9%E5%B1%95)
- [12. DOM的DOM](#12-dom%E7%9A%84dom)
- [13. 事件](#13-%E4%BA%8B%E4%BB%B6)
- [14. 表单脚本](#14-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC)
- [15. 使用Canvas绘图](#15-%E4%BD%BF%E7%94%A8canvas%E7%BB%98%E5%9B%BE)
- [16. HTML脚本编程](#16-html%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B)
- [17. 错误处理与脚本调试](#17-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%84%9A%E6%9C%AC%E8%B0%83%E8%AF%95)
- [18. Javascript与XML](#18-javascript%E4%B8%8Exml)
- [19. EX](#19-ex)
- [20. JSON](#20-json)
- [21. Ajax与Comet](#21-ajax%E4%B8%8Ecomet)
- [22. 高级技巧](#22-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7)
- [23. 离线应用与客户端存储](#23-%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8)
- [24. 最佳实践](#24-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5)
- [25. 新兴的API](#25-%E6%96%B0%E5%85%B4%E7%9A%84api)

# 1. JavaScript简介

## 1.1. JavaScript简史

最初设计的主要目的是为了处理以前由服务器端语言(如Perl)负责的一些输入验证操作。

## 1.2. JavaScript实现

一个完整的JavaScript实现由三部分组成

- 核心：ECMAScript
- 文档对象模型：DOM
- 浏览器对象模型：BOM

# 2. 在HTML中使用JavaScript

## 2.1. &lt;script&gt;元素

带有src属性的&lt;script&gt;元素不应该在其&lt;script&gt;和&lt;/script&gt;标签之间再包含额外的javascript代码。如果包含了嵌入的代码，则只会加载并执行外部脚本文件，嵌入的代码会被忽略。

### 2.1.1. 延迟脚本

HTML4.0.1为&lt;script&gt;标签定义了defer属性。这个属性的用途是表明脚本在执行时不会影响页面构造。也就是说脚本会延迟到整个页面都解析完成后再运行。相当于告诉浏览器立即下载但延迟执行。
defer属性只适用于外部文件。

### 2.1.2. 异步脚本

async只适用于外部文件脚本，其与defer的不同点：
不能保证按照指定的先后顺序执行。因此确定两者之间互不依赖很重要。

### 2.1.3. 在XHTML中的用法

什么是XHTML：将HTML作为XML的应用而重新定义的一个标准。

## 2.2. 嵌入代码与外部文件

使用外部文件的优点

- 可维护性
- 可缓存
- 适应未来

# 3. 基本概念

## 3.1. 语法

任何语言的核心都必然会描述这门语言最基本的工作原理。而描述的内容通常都要涉及这门语言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。

### 3.1.1. 区分大小写

ECMAScript中的一切(变量、函数名和操作符)都区分大小写。

### 3.1.2. 严格模式

要在整个脚本中启用严格模式，可以在顶部添加如下代码：

```javascript
"use strict"
```

也可以指定函数在严格模式下执行：

```javascript
function(){
    "use strict"
    do something;
}
```

## 3.2. 变量

ECMAScript中的变量是松散类型的。所谓的松散类型是可以保存任何类型数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。

## 3.3. 数据类型

ECMAScript中有5种简单的数据类型，也称为基本数据类型。
Undefined，Null，Boolean，Number，String和复杂的数据类型Object(本质上由一组无序的名值对组成)

### 3.3.1. typeof操作符

typeof的可能结果

- 'undefined':如果这个值未定义
- 'boolean':这个值是布尔值
- 'string': 这个值是字符串
- 'number':这个值是数值
- 'object':这个值是对象或null
- 'function':这个值是函数

typeof是一个操作符而不是函数，因此typeof(value)中的圆括号尽量可以使用，但不是必须的。

### 3.3.2. Undefined类型

Undefined类型只有一个undefined值。在使用var声明变量但未对其进行初始化时，这个变量的值就是undefined
对未初始化和未声明变量执行typeof操作符都会返回undefined

### 3.3.3. Null类型

Null类型是第二个只有一个值的数据类型，这个特殊的值是null

### 3.3.4. Boolean类型

Boolean类型的字面值true和false是区分大小写的。也就是说True和False（以及其它混合大小写形式）都不是Boolean值，只是标识符。
要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()
Boolean()值返回值规则

| 数据类型  | 转换为true的值             | 转换为false的值 |
| --------- | -------------------------- | --------------- |
| Boolean   | true                       | false           |
| String    | 任何非空字符串             | ""(空字符串)    |
| Number    | 任何非零数字值(包括无穷大) | 0和NaN          |
| Object    | 任何对象                   | null            |
| Undefined | n/a                        | undefined       |

### 3.3.5. Number类型

八进制字面值的第一位必须是零(0),然后是八进制序列(0-7)。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的值当作十进制数值解析。
ECMAScript能够表示的最小数值保存在Number.MIN_VALUE，最大值保存在Number.MAX_VALUE。如果数值超过这个范围，将自动转换成Infinity值。
要想确定一个数值是不是有穷的，可以用IsFinite()函数，这个函数在参数位于最小值与最大值之间会返回true。
NaN(not a number)即非数值，是一个特殊的数值，其特点：

- 任何涉及NaN的操作都会返回NaN
- NaN与任何值都不相等，包括NaN本身。

ECMAScript定义了isNaN()函数，判断这个参数是否"不是数值",任何不能被转换为数值的值都会导致这个函数返回true
可以把非数值转换成数值的函数：Number(),parseInt(),parseFloat()
Number()转换规则：

- 如果是Boolean值，true和false将分别转换成1和0
- 如果是数字值，则是简单的传入和传出
- 如果是null值，返回0
- 如果是undefined，返回NaN
- 如果是字符串，则遵循下列规则：
  - 如果字符串中只包含数字(包括前面带正号或者带负号的情况),则将其转换为十进制数值。注意前导零会被忽略。
  - 如果字符串中包含有效的浮点格式，则将其转换成对应的浮点数值，同样会忽略前导零。
  - 如果字符串中包含有效的十六进制格式，例如：'0xf",则将其转换为相同大小的十进制整数值。
  - 如果字符串是空的(不包含任何字符),则将其转换成0
  - 如果字符串中包含除上述格式之外的字符，则将其转换为NaN

- 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再依次按照前面的规则转换返回的字符串值。

处理整数时常用的parseInt()函数，其转换过程为：忽略字符串前面的空格，直到找到第一个非空格字符，如果第一个字符不是数字字符或负号，则会返回NaN。

```javascript
//parseInt小例子
var number = parseInt("1234blue");// 1234
var number = parseInt("");        // NaN
var number = parseInt("22.5");    // 22
var number = parseInt("0xf");     // 15(16进制数)
var number = parseInt("070");     // 56(8进制数)
var number = parseInt("70");      // 70(10进制数)
```

parseInt(value,进制)//第二个参数可以指定基数

parseFloat()与parseInt()类似，它们的区别是前者

- 第一个小数点有效
- 如终忽略前导的零

### 3.3.6. String类型

转义：

- \xnn : 以十六进制代码nn表示的一个字符(其中n为0-F).如\x41表示"A"

- \unnnn: 以十六进制代码nnnn表示的一个Unicode字符(其中n为0-F).如：\u03a3表示希腊字符

字符串转换方法

- toString()：null和undefined值没有这个方法，默认情况下数字返回十进制，也可以指定基数toString(进制)

- String()：在不知道转换的值是不是null或undefined情况下使用，这个函数能够将任何类型的值转换成字符串。如果是null，是返回"null"，undefined返回"undefined" 

### 3.3.7. Object类型

Object类型都具有的属性和方法

- Constructor：保存着用于创建当前对象的函数。
- hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在。其中，作为参数的属性名(propertyName)必须以字符串的形式指定。
- isPrototypeOf(Object):用于检查传入的对象是否是另一个对象的原型。   
- propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in语句来枚举。
- toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString():返回对象的字符串表示。
- valueOf():返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同中。

## 3.4. 操作符

### 3.4.1. 位操作符

无符号右移操作符由3个大于号(&gt;&gt;&gt;)表示。

### 3.4.2. 布尔操作符

布尔操作有三个：非(NOT)、与(AND)和或(OR)
逻辑非运算符规则：

- 如果操作数是一个对象，返回false.
- 如果操作数是一个空字符串，则返回true.
- 如果操作数是一个非空字符串，返回false.
- 如果操作数是数值0，返回true.
- 操作数是任意非零数值(包括Infinity)，返回false.
- 如果操作操作数是null，返回true.
- 操作数是NaN，返回true.
- 操作数是undefined，返回true.

### 3.4.3. 乘性操作符

乘性操作符有三个：乘法、除法和求模。
如果参与乘法计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换成数值。
### 3.4.4. 相等操作符

全等操作符由3个等号(===)表示，它只在两个操作数未经转换就相等的情况下返回true.

## 3.5. 语句

### 3.5.1. label语句

使用lable语句可以在代码中添加标签，以便将来使用。语法如下：

```javacript
label:statement
```

### 3.5.2. with语句

with语句的作用是将代码的作用域设置到一个特定的对象中，with语句的语法如下：

```javacript
with(expression) statement;
```

定义with的目的主要是为了简化多次编写同一个对象的工作。

```javacript
var qs = location.search.substring(1);
var hostName = location.hostName;
var url = location.href;
//使用with
with(location){
    var qs = search.substring(1);
    var hostName = hostName;
    var url = href;
}
```

严格模式下不允许使用with语句，否则被视为语法错误。
with语句不建议使用。

## 3.6. 函数

### 3.6.1. 理解参数

ECMAScrip函数不介意传进来多少个参数，也不在乎传进来参数是什么类型。原因是ECAMScript中的参数内部是用一个数组来表示。函数接收的始终是这个数组，而不关心数组中包含哪些参数。在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递参数的每一个参数。
ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必需的。

# 4. 变量、作用域和内存问题

## 4.1. 基本类型和引用类型的值

### 4.1.1. 传递参数

ECMAScript中所有函数的参数都是按值来传递的。
例子：

```javacript
function setName(obj){
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name);  //"Nicholas"
```

### 4.1.2. 检测类型

typeof操作符是确定一个变量是字符串、数值、布尔值，还是undefined的最佳工具。
使用typeof操作符检测函数时，返回"function"
检测引用类型的时，提供instanceof.

## 4.2. 执行环境及作用域

每个执行环境都有一个与之关联变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。
当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，由将其活动对象(activation object)作为变量对象。活动对象最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。

### 4.2.1. 没有块级作用域

JavaScript没有块级作用域。

1. 声明变量

使用var声明的变量会自动被添加到最接近的环境中。如果初始化变量时没有var声明，该变量会自动添加到全局环境。

## 4.3. 垃圾收集

### 4.3.1. 标记清除

javascript中最常用的垃圾收集方式是标记清除(mark-and-sweep).

### 4.3.2. 引用计数

另一种不太常见的垃圾收集策略叫做引用记数。

### 4.3.3. 管理内存

优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放引用--这个做法叫做解除引用(derefrencing)。

# 5. 引用类型

对象是某个特定引用类型的实例。

## 5.1. Object类型

创建Object实例的方式有两种。
第一种是new操作符后跟object构造函数。
另一种方式是使用对象字面量表示法

```javacript
var person = {
    name:"Nicholas",
    age:29
}
```

## 5.2. Array类型

与其它语言不同的是，ECMAScript数组的每一项都可以保存任何类型的数据。而且ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。
创建数组的基本方式有两种：

- 第一种是使用Array构造函数

```javacript
var colors = new Array();
```

也可以省略new操作符

```javacript
var colors = Array(3);
```

- 第二种是使用数据字面量表示法。数组的字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。

```javacript
var colors = ["red","blue","green"];
```

数组的length属性很有特点：它不是只读的。利用length属性可以方便地在数组末尾添加新项：

```javacript
colors[colors.length] = "black";
```

### 5.2.1. 检测数组

- instanceof检测

```javacript
if (value instanceof Array) {
    //对数组执行某些操作
}
```

- Array.isArray()方法

```javacript
if(Array.isArray(value)){
    //对数组执行某些操作
}
```

### 5.2.2. 栈方法

数组可以表现的像栈一样。
栈是一种LIFO(Last-In-First-Out)后进先出的数据结构。ECAMScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。
push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。

### 5.2.3. 队列方法

队列数据结构的访问规则是FIFO(First-In-First-Out)先进先出。实现这一操作的数组方法是shift(),它能够移除数组中的第一项并返回该项，同时将数组长度减速1.结合shift()和push()方法，可以像队列一样使用数组。
unshift()方法与shift()方法作用相反。它能够在数组前端添加任意个项并返回新数组的长度。因此unshift()与pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组的末尾移除项。

### 5.2.4. 重排序方法

数组中已经存在两个可以用来重排序的方法：reverse()和sort()方法。
reverse()会反转数组项的顺序。
sort()方法在默认情况下会按升序排列数组项。
sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。
sort()方法可接收一个比较函数作为参数，以便我们指定哪个值在哪个值前面。比较函数接收两个参数，如果第一个参数应该位于每二个之前同返回一个负数。如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。
比较函数示例：

```javacript
function compare(value1,value2){
    if(value1&lt;value2){
        return -1;
    }else if(value1&gt;value2){
        return 1;
    }else{
        return 0;
    }
}
```

对于数据值类型的比较函数可以简化为

```javacript
function compare(value1,value2){
  return value2 - value1;
}
```

### 5.2.5. 操作方法

#### 5.2.5.1. concat()方法

- 无参数情况下复制当前数组并返回副本

- 参数是一个或多个数组，则会将这些数组中的每一项都添加到结果数组中

- 参数不是数组，则会简单地添加到结果数组的末尾

#### 5.2.5.2. slice()方法

可接收一个或两个参数，不影响原数组

- 一个参数时，返回从该参数指定位置开始到当前数组末尾的所有项

- 两个参数时，返回起始位置和结束位置中间的项，但不包括结束位置的项。如果结束位置小于起始位置则返回空数组

如果参数中有负数，则用该数组的长度加上该数来确定位置。

#### 5.2.5.3. splice()方法（最强大的数组方法）

主要用途是向数组中部插入项，该方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）

- 删除：可以删除任意数量的项，只需要指定2个参数，要删除的第一项的位置和要删除的项数。

- 插入和替换: 向指定位置插入任意数量的项，只需要提供3个参数：起始位置、0（要删除的项数）、要插入的项（可以是多个项）。

### 5.2.6. 位置方法

两个方法：indexOf()和lastIndexOf().这两个方法都接收两个参数

- 要查找的项

- 表示查找起点的索引（可选）

### 5.2.7. 迭代方法

5个迭代方法，每个方法都接收2个参数，如下：

- 要在每一项上运行的函数，该函数会接收3个参数。
     1 数组项的值
     2 该项在数组中的位置
     3 数组对象本身

- 运行该函数的作用域对象（可选），该参数影响this的值

5个迭代方法都会对数组中的每一项运行指定函数，区别如下：

- every():如果函数对每一项都返回ture，则返回true，(&&)

- filter():返回运行指定函数返回true的项的数组。

- forEach():无返回值

- map():返回每次函数调用的结果组成的数组。

- some():如果该函数对任意一项返回ture，则返回ture,(||)

### 5.2.8. 缩小方法

2个缩小数组的方法：reduce()和reduceRight().区别是reduce()方法从数组的第一项开始，逐个遍历到最后，reduceRight()则方向相反。
两个方法都接收2个参数

- 在每一项上调用的函数,函数接收4个参数
    1 前一个值
    2 当前值
    3 项的索引
    4 数组对象

- 作为缩小基础的初始值（可选）

## 5.3. Date 类型

Date类型使用UTC(Coordinated Universal Time，国际协调时间)1970年1月1日午夜(零时)开始经过的毫秒数来保存日期。

### 5.3.1. Date.parse()

方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数，如果字符串不能表示日期，则会返回NaN.
如果直接调用Date构造函数，也会在后台调用此Date.parse()。

### 5.3.2. Date.UTC()

同样返回表示日期的毫秒数，但与Date.parse()构建值时使用不同的信息。其接收参数为：

- 年份

- 基于0的月份(一月是0，二月是1，以此类推)

- 月中的哪一天(1-31)

- 小时数(0-23)

- 分钟

- 秒

- 毫秒数

这些参数只有前两个，年和月是必需的。

## 5.4. RegExp类型

每个正则表达式可以带有一个或多个参数用以表明正则表达式行为，正则表达式的匹配模式支持以下3个标志

- g: 表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配时立即停止。

- i: 表示不区分大小写(case-insensitive)模式，即在确定匹配时忽略模式与字符串的大小写。

- m: 表示多行(mutiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

正则表达式的定义有两种方式

- 字面量形式

当要匹配的项中包含元字符时，必须对其进行转义。
正则表达式的元字符包括：

```javascript
([{\^$|?*+.}])
```

例如要匹配"[bc]at",不区分大小写

```javascript
var pattern = /\[bc\]at/i;
```

- RegExp构造函数

构造函数的模式参数是字符串，所有元字符必须进行双重转义。

### 5.4.1. RegExp 实例属性

每个实例都具有如下属性：

- global: 布尔值,表示是否设置了g标志

- ignoreCase: 布尔值，表示是否设置了i标志

- lastIndex: 整数，表示开始搜索下一个匹配项的字符位置,从0算起。

- mutiline: 布尔值，表示是否设置了m标志

- source: 正则表达式的字符串表示,按照字面量形式而非传入构造函数中的字符串模式返回。

### 5.4.2. RegExp 实例方法

- exec(): 该方法是专门为捕获组而设计的。接受一个参数,即要应用模式的字符串。返回包含第一个匹配信息的数组，或者在没有匹配项的情况下返回null。
  返回的数组是Array的实例，第一项是与整个模式匹配的字符串,其它项是与模式捕获组匹配的字符串(如果没有捕获组，则只包含一项），此外还包含两个额外的属性,index和input：
  - index表示匹配项在字符串中的位置.
  - inupt表示应用正则表达式的字符串。

  在一个字符串上多次调用exec(),将始终返回第一个匹配项的信息.而在设置全局标志的情况下,每次调用exec()都会在字符串中继续查找新匹配项。

- test():接收一个字符串参数,在模式与该参数匹配的情况下返回true,否则返回false.

### 5.4.3. RegExp 构造函数属性

| 长属性名     | 短属性名 | 说明                                     |
| ------------ | -------- | ---------------------------------------- |
| input        | $_       | 最近一次要匹配的字符串                   |
| lastMatch    | $&       | 最近一次的匹配项                         |
| lastParen    | $+       | 最近一次匹配的捕获组                     |
| leftContext  | $`       | input字符串中lastMach之前的文本          |
| mutiline     | $*       | 布尔值，表示是否所有表达式都使用多行模式 |
| rightContext | $`       | input字符串中lastMach之后的文本          |


除了上面的属性外，还有9个用于存储捕获组的构造函数属性。访问语法是 

```javascript
RegExp.$1、RegExp.$2
```

## 5.5. Function类型

定义函数的三种方法

- 声明语法

```javascript
function sum(num1,num2){
    return num1+num2;
}
```

- 函数表达式

```javascript
var sum = function(num1,num2){
    return num1+num2;
}
```

- Function构造函数(不推荐)

```javascript
var sum = new Function("num1","num2","return num1+num2");
```

使用不带圆括号的函数名访问的是函数指针，而非调用函数

### 5.5.1. 函数声明与函数表达式

解析器在向执行环境加载数据时，会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）。至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

### 5.5.2. 作为值的函数

```javascript
function CreateComparisonFunction(propertyName){
    return function(object1,object2){
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];
        if (value1<value2){
            return -1;
        }else if(value1 >value2){
            return 1;
        }else{
            return 0;
        }
    }
}

//调用
var data = {{name:"aaa",age:18},{name:"bbb",age:19}}
data.sort(CreateComparisonFunction("name"));
```

### 5.5.3. 函数内部属性

- callee属性：是一个指针，指向拥有这个arguments对象的函数。
- this属性：引用的是函数据以执行的环境对象。
- caller属性：保存着调用当前函数的函数的引用

### 5.5.4. 函数的属性和方法

每个函数都包含两个属性：

- length:表示函数希望接收的命名参数的个数。
- prototype:对于引入类型而言，它们的所有实例方法均保存在prototype中，只不过通过各自对象的实例访问罢了。prototype属性是不可枚举的，因此使用for-in无法发现。

每个函数都包含两个非继承而来的方法,apply()和call()。这两个方法都是在特定的作用域中调用函数。实际上等于设置函数体内this对象的值。

- apply():接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。
- call():接收两个参数，一个是在其中运行函数的作用域，另一个是参数，必须是一一列举的参数。

它们真正强大的地方是能扩展函数赖以运行的作用域，扩充作用域的最大好处就是对象不需要与方法有任何耦合关系。

- bind()方法

这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。

```javascript
window.color = "red";
var o = {color:"blue"};
function sayColor(){
    alert(this.color);
}
var objectSayColor = sayColor.bind(0);
objectSayColor();//blue
```

## 5.6. 基本包装类型

指三个特殊的引用类型:Boolean,Number,String.
每当读取一个基本类型值的时候，后台会创建一个对应的基本包装类型对象。

以string为例：

```javascript
var s1 = "some text";
var s2 = s1.substring(2);
```

上述过程为：

- 创建String类型的一个实例。
- 在实例上调用指定方法
- 销毁这个实例

引用类型与基本包装类型的主要区别：
在于对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后立即被销毁。

对基本包装类型的实例调用typeof会返回object,而且所有基本包装类型的对象都会被转换为布尔值true.

### 5.6.1. Boolean 类型

基本类型与引用类型的布尔值有两个区别：

- typeof :基本类型返回“boolean”,引用类型返回"object"

- insatanceof:Boolean对象会返回true,基本类型会返回false

### 5.6.2. Number 类型

Number类型提供了一引起用于将数值格式化为字符串的方法

- toFixed():按照指定的小数位返回数值的字符串表示。

- toExponential():返回指数表示法表示的数值的字符串形式。接收一个参数，用于指定输出结果中的小数位数。

- toPrecision():得到表示某个数值的最合适形式。这个方法接收一个参数，表示数值的所有数字的位数(不包括指数部分)。

### 5.6.3. String 类型

1 字符方法

charAt()和charCodeAt()。这两个方法都接收一个参数，即基于0的字符串位置。charAt()得到字符，而charCodeAt()得到的是字符编码。

2 字符串操作方法

- concat():用于将一或多个字符串拼接起来。
- slice()，substring(): 接收一或两个参数，第一个用于指字子字符串的开始位置，第二个（在指定的情况下）指定的是子字符串最后一个字符后面的位置。
- substr: 接收一或两个参数，第一个用于指字子字符串的开始位置，第二个（在指定的情况下）指定的是返回的字符串个数。

在传入参数是负数的情况下
slice()会将传入的负值与字符串的长度相加。
substr()方法会将负的第一个参数加上字符串的长度，而负的第二个参数转换为0
substring()方法会将所有负值参数转换为0

3 字符串位置方法

indexOf()和lastIndexOf():从字符串中搜索给定的子字符串，如果没有找到则返回-1.

4 trim()方法

这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。

5 字符串大小写转换方法

toLowerCase()、toLocalLowerCase()、toUpperCase()、toLocalUpperCase()

6 字符串的模式匹配方法

- match():本质上与调用RegExp的exec()方法相同。只接收一个参数，要么是一个正则表达式，要么是一个RegExp对象。

- search():返回字符串中第一个匹配项的索引。如果没有找到匹配项，则返回-1。该方法始终从字符串的开头向后查找。
- replace():接收两个参数，第一个参数可以是一个RegExp对象或者一个字符串(这个字符串不会被转换成正则表达式).第二个参数可以是一个字符串或才函数。如果第一参数是字符串，则只会替换第一个子字符串。要想替换所有的字符串，唯一的办法是提供一个正则表达式，而且指定全局(g)标志。

第二个参数也可以是一个函数。在只有一个匹配项的时候，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项···，会最后两个参数仍然与一个匹配项时相同。

7 localCompare()方法
比较两个字符串，并返回下列值中的一个

- 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数。
- 如果字符串等于字符串参数，则返回0
- 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数。

8 fromCharCode()方法

String 构造函数本身的一个静态方法，这个方法接收一或多个字符编码，然后将他们转换为字符串。

## 单体内置对象



# 6. 面向对象的程序设计

# 7. 函数表达式

# 8. BOM

# 9. 客户端检测

# 10. DOM

# 11. DOM扩展

# 12. DOM的DOM

# 13. 事件

# 14. 表单脚本

# 15. 使用Canvas绘图

# 16. HTML脚本编程

# 17. 错误处理与脚本调试

# 18. Javascript与XML

# 19. EX

# 20. JSON

# 21. Ajax与Comet

# 22. 高级技巧

# 23. 离线应用与客户端存储

# 24. 最佳实践

# 25. 新兴的API




